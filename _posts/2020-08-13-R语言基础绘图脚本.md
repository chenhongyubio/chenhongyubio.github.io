---
layout: post # 使用的布局（不需要改）
title: R语言可视化 # 标题
subtitle: R语言基础可视化绘图脚本 #副标题
date: 2020-08-13 # 时间
author: CHY # 作者
header-img: img/wallhaven-Rimage.jpg #这篇文章标题背景图片
catalog: true # 是否归档
tags: #标签
  - 生物信息
---

根据 bioinformics 公众号整理，主要收集 R 语言绘制基本图形的脚本便于后续科研使用，仅做个人学习使用。<br>

### 散点图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/01scatterplot/")
# 读取示例数据
data <- read.table("demo_scatterplot.txt", header = T, check.names = F)
# 查看数据
head(data)
dim(data)
# 绘散点图
attach(data)
plot(BRCA1, BRCA2, col="red", pch=16)

# 线性拟合
lm.fit <- lm(BRCA2 ~ BRCA1)
summary(lm.fit)
abline(lm.fit, lty=2, lwd = 2, col="blue") # 添加拟合曲线

# 计算pearson相关性
cor_pearson <- cor.test(BRCA1, BRCA2, method = "pearson")
cor_pearson
cor_coef <- cor_pearson$estimate
cor_pvalue <- cor_pearson$p.value

plot(BRCA1,BRCA2,col="red",pch=16,
     main = paste0("Pearson r = ",round(cor_coef,digits = 2)," P-value = ",cor_pvalue))
# 添加拟合直线
abline(lm.fit, lty=2, lwd = 2, col="blue")
# 添加拟合直线方程
a <- lm.fit$coefficients[2]
b <- lm.fit$coefficients[1]
a <- round(a, 3)
b <- round(b, 3)
text(x = -0.4, y = 0.2, labels = paste("y = ", a, " * x + ", b, sep = ""), cex = 1.5)
detach(data)
```

```
# ggplot2绘制散点图
library(ggplot2)
library(ggpubr)
p1 <- ggplot(data = data, mapping = aes(x = BRCA1, y = BRCA2)) +
      geom_point(colour = "red", size = 2) +
      geom_smooth(method = lm, colour='blue', fill='gray') #添加拟合曲线
p1
p1 + stat_cor(method = "pearson", label.x = -0.4, label.y = 0.2) #添加pearson相关系数
```

```
# ggpubr包绘制散点图
library(ggpubr)
ggscatter(data, x = "BRCA1", y = "BRCA2",
          color = "red", size =2, # Points color and size
          add = "reg.line",  # Add regression line
          add.params = list(color = "blue", fill = "gray"), # Customize regression line
          conf.int = TRUE, # Add confidence interval
          cor.coef = TRUE, # Add correlation coefficient. see ?stat_cor
          cor.coeff.args = list(method = "pearson"))
```

### 折线图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/02lineplot/")
# 读取示例数据
data <- read.table("demo1_lineplot.txt", header = T, check.names = F)
# 查看数据
head(data)
dim(data)
attach(data)
plot(x, y1, type = "b", pch = 15, lty = 1, col = "red", xlab = "时间", ylab = "反应强度", ylim = c(-1,30))
lines(x, y2, type = "b", pch = 16, lty = 2, col = "blue")
lines(x, y3, type = "b", pch = 17, lty = 3, col = "purple")
legend("topleft", inset = 0.02, title = "样品", c("y1","y2","y3"),
       lty = c(1,2,3), pch = c(15,16,17), col = c("red","blue","purple"),
       bg = "gray")
detach(data)
```

```
# ggplot2绘制折线图（带误差线）
library(ggplot2)
# 读取示例数据
data2 <- read.table("demo2_lineplot.txt", header = T, row.names = 3, sep="\t", check.names = F)
data2$Stage <- factor(data2$Stage,levels = c("0 min","10 min","20 min","30 min","45 min","60 min","90 min","120 min"))
# 查看数据
head(data2)
# 定义函数计算平均值和标准差
data_summary <- function(data, varname, groupnames){
  require(plyr)
  summary_func <- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      sd = sd(x[[col]], na.rm=TRUE))
  }
  data_sum <- ddply(data, groupnames, .fun=summary_func, varname)
  data_sum <- rename(data_sum, c("mean" = varname))
  return(data_sum)
}

data2 <- data_summary(data2, varname="Expression",
                      groupnames=c("Stage"))
head(data2)

ggplot(data2, aes(x=Stage, y=Expression, group=1, color=Stage)) +
      geom_errorbar(aes(ymin=Expression-sd, ymax=Expression+sd), width=.1) +
      geom_line() + geom_point()+
      scale_color_brewer(palette="Paired")+theme_bw()
```

```
# ggplot2包绘制聚类趋势折线图
# 读取示例数据
data3 <- read.table("demo3_lineplot.txt",header = T,check.names = F)
# 查看数据
head(data3)
library(reshape2)
# 将宽数据格式转换为长数据格式
data3 = melt(data3)
head(data3)
names(data3) <- c("Gene","Group","Stage","Expression")
ggplot(data3,aes(x=Stage, y=Expression, group=Gene)) + geom_line(color="gray90",size=0.8) +
      geom_hline(yintercept =0,linetype=2) +
      stat_summary(aes(group=1),fun.y=mean, geom="line", size=1.2, color="#c51b7d") +
      facet_wrap(.~Group) + theme_bw() +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
            axis.text = element_text(size=8, face = "bold"),
            strip.text = element_text(size = 10, face = "bold"))
```

### 条形图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/02lineplot/")
# 使用mtcars内置数据集
head(mtcars)
# 使用table函数进行计数
counts <- table(mtcars$cyl)
counts
# 默认条形图垂直放置
barplot(counts,xlab = "mtcars$cyl", ylab = "counts",
        col = heat.colors(3))
# 设置horiz = T参数进行水平放置
barplot(counts,xlab = "mtcars$cyl", ylab = "counts",
        col = heat.colors(3), horiz = T)

# 绘制分组条形图
counts <- table(mtcars$cyl,mtcars$carb)
counts
# 默认为堆砌条形图
barplot(counts, xlab = "cyl", ylab = "carb", legend = T,
        col = c("red","blue","green"), main = "Group of cyl and carb")
# 设置beside = T参数绘制并列分组条形图
barplot(counts, xlab = "cyl", ylab = "carb", beside = T, legend = T,
        col = c("red","blue","green"), main = "Group of cyl and carb")
```

```
# ggplot2包绘制分组条形图
# 读取示例数据
data <- read.table("demo1_barplot.txt",header = T, check.names = F, sep = "\t")
# 查看数据
head(data)
library(ggplot2)
library(reshape2)
# 需要将数据进行结构变换
data <- melt(data,variable.name = "Cluster", value.name = "Count")

# 设置position = "stack"参数绘制堆砌条形图
ggplot(data, aes(Cluster, Count, fill=Annotation)) +
  geom_bar(stat = "identity", position = "stack") + theme_bw() + theme(legend.position = "top")
# 设置position = "dodge"参数绘制并列条形图
ggplot(data, aes(Cluster, Count, fill=Annotation)) +
  geom_bar(stat = "identity", position = "dodge") + theme_bw() + theme(legend.position = "top")
# 设置position = "fill"参数绘制填充条形图
ggplot(data, aes(Cluster, Count, fill=Annotation)) +
  geom_bar(stat = "identity", position = "fill") +
  theme_bw() + theme(legend.position = "top")
# 添加coord_flip参数进行水平翻转
ggplot(data, aes(Cluster, Count, fill=Annotation)) +
  geom_bar(stat = "identity", position = "fill") +
  theme_bw() + theme(legend.position = "top") + coord_flip()
```

```
# ggpubr包绘制带误差棒的条形图
# 读取示例数据
data <- read.table("demo2_barplot.txt",header = T,row.names = 1, check.names = F, sep = "\t")
# 查看数据
head(data)
library(ggpubr)
ggbarplot(data, x = "Stage", y = "TPM",
          color = "Gender", fill = "Gender",
          add = c("mean_se","dotplot"), width = 0.6,
          position = position_dodge())
# 调整方向
ggbarplot(data, x = "Stage", y = "TPM", orientation = "horiz",
          color = "Gender", fill = "Gender",
          add = c("mean_se","jitter"), width = 0.6,
          palette = c("#00AFBB", "#E7B800"),
          position = position_dodge())

```

### 频率直方图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/02lineplot/")

# 使用内置mtcars数据集
head(mtcars)
head(mtcars$mpg)

# 基础hist函数绘制频率直方图
hist(mtcars$mpg)
hist(mtcars$mpg, breaks = 10, col = "blue",
     freq = F, # 表示不按照频数绘图
     xlab = "Miles per Gallon")
# 添加密度曲线
lines(density(mtcars$mpg),col= "red",lwd=2)
# 添加轴须线
rug(jitter(mtcars$mpg))
```

```
# ggplot2包绘制直方图
library(ggplot2)
# 读取示例数据
data <- read.table("demo_histgram.txt")
names(data) <- "length"
head(data)
ggplot(data,aes(length,..density..)) + xlim(c(0,1000)) +
  geom_histogram(binwidth = 2, fill="red") +
  xlab("Insertion Size (bp)") +
  theme_bw()
```

```
# ggpubr包绘制直方图
library(ggpubr)
# Create some data format
set.seed(1234)
wdata = data.frame(
  sex = factor(rep(c("F", "M"), each=200)),
  weight = c(rnorm(200, 55), rnorm(200, 58)))
head(wdata)

gghistogram(wdata, x = "weight",
            fill = "lightgray", # 设置填充色
            add = "mean", # 添加均值线
            rug = TRUE # 添加轴须线
            )

# Change outline and fill colors by groups ("sex")
# Use custom color palette
gghistogram(wdata, x = "weight",
            add = "mean", rug = TRUE,
            color = "sex", fill = "sex",
            palette = c("#00AFBB", "#E7B800") # 设置画板颜色
            )

# Combine histogram and density plots
gghistogram(wdata, x = "weight",
            add = "mean", rug = TRUE,
            fill = "sex", palette = c("#00AFBB", "#E7B800"),
            add_density = TRUE # 添加密度曲线
            )
```

### 密度分布图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/02lineplot/")

data <- read.table("demo_density.txt",header = T,row.names = 1,check.names = F)
head(data)
data <- as.data.frame(t(data))
gene_num <- ncol(data)
# 绘制第一个基因的密度分布图(数据结构对应)
plot(density(data[,1]), col=rainbow(gene_num)[1], lty=1,
     xlab = "Expression level", main = names(data)[1])
polygon(density(data[,1]),col=rainbow(gene_num)[1])

# 绘制所有基因的密度分布图（先绘制单个基因，然后再添加其他基因）
plot(density(data[,1]), col=rainbow(gene_num)[1], lty=1,
     xlab = "Expression level", ylim = c(0,1.5), main = "")
# polygon(density(data[,1]),col=rainbow(gene_num)[1])
# 添加其他基因的密度曲线
for (i in seq(2,gene_num)){
  lines(density(data[,i]), col=rainbow(gene_num)[i], lty=i)
  #polygon(density(data[,i]),col=rainbow(gene_num)[i])
}
# 添加图例
legend("topright", inset = 0.02, title = "Gene", names(data),
       col = rainbow(gene_num), lty = seq(1,gene_num), bg = "gray")
```

```
# ggplot2包绘制密度分布图
library(ggplot2)
library(reshape2)
data <- read.table("demo_density.txt",header = T,check.names = F)
data <- melt(data)
## Using gene as id variables
head(data)
# 使用geom_density函数绘制密度分布曲线
ggplot(data,aes(value,fill=gene, color=gene)) +
  xlab("Expression level") +
  geom_density(alpha = 0.6) +
  geom_rug() + theme_bw()

# 使用geom_line函数绘制密度分布曲线
ggplot(data,aes(value,..density.., color=gene))  +
  geom_line(stat="density") +
  theme_bw() + facet_wrap(.~gene) +
  theme(axis.title = element_text(size=16),
        axis.text=element_text(size=16))
```

```
# ggpubr包绘制密度分布图
data <- read.table("demo_density.txt",header = T,check.names = F)
data <- melt(data)
## Using gene as id variables
head(data)
library(ggpubr)
# 使用ggdensity函数绘制密度分布曲线
ggdensity(data, x = "value",
          rug = TRUE, xlab = "Expression level",
          color = "gene", fill = "gene")

# 添加分面
ggdensity(data, x = "value",
          facet.by = "gene", linetype = "gene",
          rug = TRUE, xlab = "Expression level",
          color = "gene", fill = "gene")
```

### 饼图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/02lineplot/")

# 基础pie函数绘制饼图
data <- read.table("demo1_piechart.txt",header = T)
head(data)
pie(data$value)

pie(data$value,
    labels = data$group, # 添加标签
    col = c("purple", "violetred1", "green3",
            "cornsilk", "cyan") # 设置颜色
)

pie(data$value,
    labels = data$group,
    col = c("purple", "violetred1", "green3",
            "cornsilk", "cyan"),
    clockwise = T, # 逆时针排布
    init.angle = 45 # 设置第一个扇区的初始角度
    )

pie(data$value,
    labels = data$group, # 添加标签
    col = c("purple", "violetred1", "green3",
            "cornsilk", "cyan"), # 设置颜色
    density = 20, # 设置阴影线密度
    angle = 20 + 10 * 1:5 # 设置阴影线角度
)

per.labs <- paste0(data$group,": ",round(100 * data$value / sum(data$value),2),"%")
pie(data$value,
    labels = per.labs, # 添加标签
    col = c("purple", "violetred1", "green3",
            "cornsilk", "cyan"),
    main = "pie(*, clockwise = TRUE)"
)
# 添加图例
legend("topright",legend = data$group, cex=1.0,
       fill = c("purple", "violetred1", "green3", "cornsilk", "cyan")
       )
```

```
# ggplot2包绘制饼图
library(ggplot2)
data <- read.table("demo1_piechart.txt",header = T)
# 计算百分比
data$percent <- paste0(round(100 * data$value / sum(data$value),2),"%")
head(data)
ggplot(data,aes(x="", y= value, fill = group)) +
  geom_bar(stat = "identity",color="white") + theme_bw() +
  scale_fill_manual(values = c("purple", "violetred1", "green3", "cornsilk", "cyan")) +
  theme(axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()) +
  labs(x="", y="") +
  geom_text(aes(y = value/2 + c(0, cumsum(value)[-length(value)]),
                label = paste0(group,": ", percent)), size=5) +
  coord_polar(theta = "y")
```

```
# ggpubr包绘制饼图
library(ggpubr)
data <- read.table("demo1_piechart.txt",header = T)
# 添加百分比标签列
data$labs <- paste0(data$group,": ",round(100 * data$value / sum(data$value),2),"%")
head(data)
ggpie(data,x="value", label = "labs",
      lab.pos = "in", lab.font = "5",
      fill="group", color="white",
      palette = c("purple", "violetred1", "green3", "cornsilk", "cyan"))
```

```
# pie3D函数绘制三维饼图
# 加载plotrix包
library(plotrix)
data <- read.table("demo1_piechart.txt",header = T)
# 添加百分比标签列
data$labs <- paste0(data$group,": ",round(100 * data$value / sum(data$value),2),"%")
head(data)
pie3D(data$value, labels = data$labs,
      theta = pi/5, labelcex=1.2,
      explode = 0.1, main = "3D pie chart",
      col = c("purple", "violetred1", "green3", "cornsilk", "cyan"))
# 添加图例
legend("topright",legend = rev(data$group), cex=1.0, inset = 0.01,
       fill = rev(c("purple", "violetred1", "green3", "cornsilk", "cyan"))
)
```

### 箱线图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/02lineplot/")

head(InsectSprays)
boxplot(count ~ spray, data = InsectSprays, col = "lightgray")

boxplot(count ~ spray, data = InsectSprays,
        notch = TRUE, col = "blue")

## boxplot on a matrix:
mat <- cbind(Uni05 = (1:100)/21, Norm = rnorm(100),
             `5T` = rt(100, df = 5), Gam2 = rgamma(100, shape = 2))
head(mat)
boxplot(mat)

## boxplot on a data frame:
df <- as.data.frame(mat)
par(las = 1) # all axis labels horizontal
boxplot(df, main = "boxplot(*, horizontal = TRUE)",
        col = "red", notch = T, horizontal = TRUE)

## 分组箱线图-1
## Using 'at = ' and adding boxplots -- example idea by Roger Bivand :
head(ToothGrowth)
boxplot(len ~ dose, data = ToothGrowth,
        subset = supp == "VC",
        at = 1:3 - 0.2,
        boxwex = 0.25,
        col = "yellow",
        main = "Guinea Pigs' Tooth Growth",
        xlab = "Vitamin C dose mg",
        ylab = "tooth length",
        xlim = c(0.5, 3.5), ylim = c(0, 35), yaxs = "i")
boxplot(len ~ dose, data = ToothGrowth,
        add = TRUE,
        subset = supp == "OJ",
        at = 1:3 + 0.2,
        boxwex = 0.25,
        col = "orange")
legend("topleft", c("Ascorbic acid", "Orange juice"),
       fill = c("yellow", "orange"))

## 分组箱线图-2
boxplot(len ~ dose:supp, data = ToothGrowth,
        boxwex = 0.5, col = c("orange", "yellow"),
        main = "Guinea Pigs' Tooth Growth",
        xlab = "Vitamin C dose mg", ylab = "tooth length",
        sep = ":", lex.order = TRUE, ylim = c(0, 35), yaxs = "i")
```

```
# ggplot2包绘制箱线图
library(ggplot2)
data <- read.table("demo1_boxplot.txt",header = T)
head(data)
ggplot(data,aes(sample_type,BRCA1,fill=sample_type)) +
        geom_boxplot()

# 添加扰动点，更改离群点的颜色，形状和大小
ggplot(data,aes(sample_type,BRCA1,fill=sample_type)) +
        geom_boxplot(width=0.5,outlier.color = "red",outlier.shape = 2,outlier.size = 3) +
        geom_jitter(shape=16, position=position_jitter(0.2))

# 添加notch，更改颜色
ggplot(data,aes(sample_type,BRCA1,fill=sample_type)) +
        geom_boxplot(notch = T,width=0.5,alpha=0.8) +
        scale_fill_brewer(palette="Set1")

# 添加均值点
ggplot(data,aes(sample_type,BRCA1,fill=sample_type)) +
        geom_boxplot(notch = T,width=0.5,alpha=0.8) +
        scale_fill_brewer(palette="Set1") +
        stat_summary(fun.y="mean",geom="point",shape=23,
                     size=4,fill="white")

# 添加误差棒
ggplot(data,aes(sample_type,BRCA1,fill=sample_type)) +
        geom_boxplot(notch = T,width=0.5,alpha=0.8) +
        stat_boxplot(geom = "errorbar",width=0.1) +
        scale_fill_brewer(palette="Set1") +
        stat_summary(fun.y="mean",geom="point",shape=23,
                     size=4,fill="white")

# 更换主题背景，旋转坐标轴
ggplot(data,aes(sample_type,BRCA1,fill=sample_type)) +
        stat_boxplot(geom = "errorbar",width=0.1) +
        geom_boxplot(notch = T,width=0.5,alpha=0.8) +
        scale_fill_brewer(palette="Set1") +
        stat_summary(fun.y="mean",geom="point",
                     shape=23,size=4,fill="white") +
        theme_bw() + coord_flip()
```

```
# ggpubr包绘制箱线图
library(ggpubr)
data <- read.table("demo1_boxplot.txt",header = T)
head(data)

ggboxplot(data,x="sample_type",y="BRCA1",
          width = 0.6,fill="sample_type")

# 添加notch，扰动点，更改颜色
ggboxplot(data,x="sample_type",y="BRCA1",
          width = 0.6,fill="sample_type",
          notch = T,palette = c("#00AFBB", "#E7B800"),
          add = "jitter",shape="sample_type")

# 添加误差棒和均值
ggboxplot(data,x="sample_type",y="BRCA1",
          width = 0.6,fill="sample_type",
          bxp.errorbar = T, bxp.errorbar.width = 0.2,
          add = "mean",add.params = list(size=1,color="white"))

# 旋转坐标轴
ggboxplot(data,x="sample_type",y="BRCA1",
          width = 0.6,fill="sample_type",
          add = "mean",add.params = list(size=1,color="white"),
          notch = T,orientation = "horizontal")
```

### 小提琴图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/02lineplot/")

library(vioplot)
data("iris")
head(iris)
vioplot(Sepal.Length~Species, data = iris,
        main = "Sepal Length", # 设置标题
        col=c("lightgreen", "lightblue", "palevioletred")) # 设置小提琴颜色
# 添加图例
legend("topleft", legend=c("setosa", "versicolor", "virginica"),
       fill=c("lightgreen", "lightblue", "palevioletred"), cex = 1.2)

data("diamonds", package = "ggplot2")
head(diamonds)
# 设置画板颜色
palette <- RColorBrewer::brewer.pal(9, "Pastel1")
palette
par(mfrow=c(3, 1))
vioplot(price ~ cut, data = diamonds, las = 1, col = palette)
vioplot(price ~ clarity, data = diamonds, las = 2, col = palette)
vioplot(price ~ color, data = diamonds, las = 2, col = palette)

#generate example data
data_one <- rnorm(100)
data_two <- rnorm(50, 1, 2)
head(data_one)
head(data_two)
par(mfrow=c(2,2))
#colours can be customised separately, with axis labels, legends, and titles
vioplot(data_one, data_two,
        col=c("red","blue"), #设置小提琴颜色
        names=c("data one", "data two"),
        main="data violin",
        xlab="data class", ylab="data read")
legend("topleft", fill=c("red","blue"), legend=c("data one", "data two"))

#colours can be customised for the violin fill and border separately
vioplot(data_one, data_two,
        col="grey85", border="purple",
        names=c("data one", "data two"),
        main="data violin",
        xlab="data class", ylab="data read")

#colours can also be customised for the boxplot rectange and lines (border and whiskers)
vioplot(data_one, data_two,
        col="grey85", rectCol="lightblue", lineCol="blue",
        border="purple", names=c("data one", "data two"),
        main="data violin", xlab="data class", ylab="data read")

#these colours can also be customised separately for each violin
vioplot(data_one, data_two,
        col=c("skyblue", "plum"),
        rectCol=c("lightblue", "palevioletred"),
        lineCol="blue", border=c("royalblue", "purple"),
        names=c("data one", "data two"),
        main="data violin", xlab="data class", ylab="data read")

par(mfrow=c(1,1))
#this applies to any number of violins, given that colours are provided for each
vioplot(data_one, data_two, rnorm(200, 3, 0.5), rpois(200, 2.5),  rbinom(100, 10, 0.4),
        col=c("red", "orange", "green", "blue", "violet"), horizontal = T,
        rectCol=c("palevioletred", "peachpuff", "lightgreen", "lightblue", "plum"),
        lineCol=c("red4", "orangered", "forestgreen", "royalblue", "mediumorchid"),
        border=c("red4", "orangered", "forestgreen", "royalblue", "mediumorchid"),
        names=c("data one", "data two", "data three", "data four", "data five"),
        main="data violin", xlab="data class", ylab="data read")
```

```
# ggplot2包绘制小提琴图
library(ggplot2)
head(diamonds)
ggplot(diamonds,aes(cut,log(price),fill=cut)) +
  geom_violin()

# 更换填充色，设置分面
ggplot(diamonds,aes(cut,log(price),fill=cut)) +
  geom_violin() +
  scale_fill_manual(values = c("palevioletred", "peachpuff", "lightgreen", "lightblue", "plum")) +
  facet_wrap(.~clarity,ncol = 4)

# 添加箱线图和均值点
ggplot(diamonds,aes(cut,log(price),fill=cut)) +
  geom_violin() +
  geom_boxplot(width=0.1,position = position_identity(),fill="white") +
  stat_summary(fun.y="mean",geom="point",shape=23, size=4,fill="red") +
  theme_bw() + theme(legend.position = "top")
```

```
# ggpubr包绘制小提琴图
library(ggpubr)
data("ToothGrowth")
df <- ToothGrowth
head(df)
ggviolin(df, x = "dose", y = "len", color = "supp")

# Change the plot orientation: horizontal
ggviolin(df, "dose", "len", fill = "supp",orientation = "horiz")

# Add box plot
ggviolin(df, x = "dose", y = "len", fill = "dose",
         add = "boxplot",add.params = list(fill="white"))

ggviolin(df, x = "dose", y = "len", fill = "supp",
         add = "dotplot")

# Add jitter points and
# change point shape by groups ("dose")
ggviolin(df, x = "dose", y = "len", fill = "supp",
         add = "jitter", shape = "dose")

# Add mean_sd + jittered points
ggviolin(df, x = "dose", y = "len", fill = "dose",
         add = c("jitter", "mean_sd"))

# Change error.plot to "crossbar"
ggviolin(df, x = "dose", y = "len", fill = "dose",
         add = "mean_sd", error.plot = "crossbar")

# Change colors
# Change outline colors by groups: dose
# Use custom color palette and add boxplot
ggviolin(df, "dose", "len",  color = "dose",
         palette = c("#00AFBB", "#E7B800", "#FC4E07"),
         add = "boxplot")

# Change fill color by groups: dose
# add boxplot with white fill color
ggviolin(df, "dose", "len", fill = "dose",
         palette = c("#00AFBB", "#E7B800", "#FC4E07"),
         add = "boxplot", add.params = list(fill = "white"))

ggviolin(df, "dose", "len", facet.by = "supp", color = "supp",
         palette = c("#00AFBB", "#E7B800"), add = "boxplot")
```

### 韦恩图

```
# 清除当前环境中的变量
rm(list=ls())
# 设置工作目录
setwd("C:/Users/Dell/Desktop/R_Plots/02lineplot/")
```

```
# gplots包绘制韦恩图
library(gplots)
data <- read.table("demo1_venn.txt", header = T, sep = "\t") # 矩阵或者数据框
head(data)
attach(data)
# 绘制二维韦恩图
venn(data = list(Set1,Set2))
# 绘制三维韦恩图
venn(data = list(Set1,Set2,Set3))
# 绘制四维韦恩图
venn(data = list(Set1,Set2,Set3,Set4))
# 绘制五维韦恩图
venn(data = list(Set1,Set2,Set3,Set4,Set5))
```

```
# VennDiagram包绘制韦恩图
library(VennDiagram)
# 使用draw.single.venn函数绘制一维韦恩图
venn.plot <- draw.single.venn(
  area = 365,
  category = "All\nDays",
  lwd = 5,
  lty = "blank",
  cex = 3,
  label.col = "orange",
  cat.cex = 4,
  cat.pos = 180,
  cat.dist = -0.20,
  cat.col = "white",
  fill = "red",
  alpha = 0.15
);
grid.newpage();

# 使用draw.pairwise.vennh函数绘制二维韦恩图
venn.plot <- draw.pairwise.venn(
  area1 = 100,
  area2 = 70,
  cross.area = 68,
  category = c("First", "Second"),
  fill = c("blue", "red"),
  lty = "blank",
  cex = 2,
  cat.cex = 2,
  cat.pos = c(285, 105),
  cat.dist = 0.09,
  cat.just = list(c(-1, -1), c(1, 1)),
  ext.pos = 30,
  ext.dist = -0.05,
  ext.length = 0.85,
  ext.line.lwd = 2,
  ext.line.lty = "dashed"
);
grid.newpage();

# 使用draw.triple.vennh函数绘制三维韦恩图
venn.plot <- draw.triple.venn(
  area1 = 65,
  area2 = 75,
  area3 = 85,
  n12 = 35,
  n23 = 15,
  n13 = 25,
  n123 = 5,
  category = c("First", "Second", "Third"),
  fill = c("blue", "red", "green"),
  lty = "blank",
  cex = 2,
  cat.cex = 2,
  cat.col = c("blue", "red", "green")
);
grid.newpage();

# 使用draw.quad.venn函数绘制四维韦恩图
# Reference four-set diagram
venn.plot <- draw.quad.venn(
  area1 = 72,
  area2 = 86,
  area3 = 50,
  area4 = 52,
  n12 = 44,
  n13 = 27,
  n14 = 32,
  n23 = 38,
  n24 = 32,
  n34 = 20,
  n123 = 18,
  n124 = 17,
  n134 = 11,
  n234 = 13,
  n1234 = 6,
  category = c("First", "Second", "Third", "Fourth"),
  fill = c("orange", "red", "green", "blue"),
  lty = "dashed",
  cex = 2,
  cat.cex = 2,
  cat.col = c("orange", "red", "green", "blue")
);
grid.newpage();

# 使用draw.quintuple.venn函数绘制五维韦恩图
# Reference five-set diagram
venn.plot <- draw.quintuple.venn(
  area1 = 301,
  area2 = 321,
  area3 = 311,
  area4 = 321,
  area5 = 301,
  n12 = 188,
  n13 = 191,
  n14 = 184,
  n15 = 177,
  n23 = 194,
  n24 = 197,
  n25 = 190,
  n34 = 190,
  n35 = 173,
  n45 = 186,
  n123 = 112,
  n124 = 108,
  n125 = 108,
  n134 = 111,
  n135 = 104,
  n145 = 104,
  n234 = 111,
  n235 = 107,
  n245 = 110,
  n345 = 100,
  n1234 = 61,
  n1235 = 60,
  n1245 = 59,
  n1345 = 58,
  n2345 = 57,
  n12345 = 31,
  category = c("A", "B", "C", "D", "E"),
  fill = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.cex = 2,
  margin = 0.05,
  cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
          1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
  ind = TRUE
);
grid.newpage();

# Writing to file
tiff(filename = "Quintuple_Venn_diagram.tiff", compression = "lzw");
grid.draw(venn.plot);
dev.off();'

# 使用venn.diagram函数绘制韦恩图
# 五维韦恩图
venn.plot <- venn.diagram(
  x = list(Set1=Set1,Set2=Set2,Set3=Set3,Set4=Set4,Set5=Set5),
  filename = NULL,
  col = "black",
  fill = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  alpha = 0.50,
  cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
          1, 0.8, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
  cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.cex = 1.5,
  cat.fontface = "bold",
  margin = 0.05
);
grid.draw(venn.plot);
grid.newpage();
```

### 集合图绘制

```
# upset集合图绘制
library(UpSetR)
# 加载UpSetR包的内置数据集
movies <- read.csv(system.file("extdata", "movies.csv", package = "UpSetR"), header = T, sep = ";")
dim(movies)
head(movies)

upset(data = movies,
      sets = c("Action", "Adventure", "Comedy", "Drama", "Mystery",
               "Thriller", "Romance", "War", "Western"), # 指定所用的集合
      number.angles = 30, # 设置相交集合柱状图上方数字的角度
      point.size = 3.5, # 设置矩阵中圆圈的大小
      line.size = 2, # 设置矩阵中连接圆圈的线的大小
      mainbar.y.label = "Genre Intersections", # 设置y轴标签
      sets.x.label = "Movies Per Genre", # 设置x轴标签
      mb.ratio = c(0.6, 0.4), # 设置bar plot和matrix plot图形高度的占比
      order.by = "freq")

具体参数使用：https://mp.weixin.qq.com/s/WPzmDbHosxXKSXOWSl3G4Q
```

#### 火山图绘制

```
# base plot绘制火山图
data <- read.table("demo_volcano.txt",header = T,
                   check.names = F,row.names = 1,sep="\t")
head(data)
attach(data)
# 基础火山图
plot(x=`log2_Ratio(WT0/LOG)`,y=-1*log10(FDR))
# 添加水平线和垂直线
abline(v=c(-1,1),lty=2,lwd = 2,col="red")
abline(h=-log10(0.05),lty=2,lwd=2,col="blue"
# 添加图例
legend("topright", inset = 0.01, title = "Significant", c("yes","no"),
       pch=c(16,16),col = c("red","black"))
# 添加gene注释信息
gene_selected <- c("Unigene0034898","Unigene0038455","Unigene0003997",
                   "Unigene0026444","Unigene0039482","Unigene0028163"
                   )
data_selected <- data[gene_selected,]
text(x=data_selected$`log2_Ratio(WT0/LOG)`,y=-1*log10(data_selected$FDR),
     labels = rownames(data_selected),col="red",adj = 0.5)
detach(data)
```

```
# ggplot2绘制火山图
library(ggplot2)
head(data)
ggplot(data,aes(`log2_Ratio(WT0/LOG)`,-log10(FDR))) + geom_point()
# 添加颜色和标题
ggplot(data,aes(`log2_Ratio(WT0/LOG)`,-log10(FDR),color=significant)) +
  geom_point() +
  labs(title="Volcano plot",x=expression(log[2](FC)), y=expression(-log[10](FDR)))
# 更改颜色，主题，添加水平线和垂直线，去掉网格线
p <- ggplot(data,aes(`log2_Ratio(WT0/LOG)`,-log10(FDR),color=significant)) +
  geom_point() + theme_bw() +
  labs(title="Volcano plot",x=expression(log[2](FC)), y=expression(-log[10](FDR))) +
  scale_color_manual(values = c("blue","red")) +
  geom_vline(xintercept=-1, linetype=2, colour="gray30") +
  geom_vline(xintercept=1, linetype=2, colour="gray30") +
  geom_hline(yintercept=-log(0.05), linetype=2, colour="gray30") +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())
p
# 添加基因注释信息
library(ggrepel)
p + geom_text_repel(data=data_selected,
                    aes(label=rownames(data_selected)))
p + geom_label_repel(data=data_selected,
                     aes(label=rownames(data_selected)))
```

```
# ggpubr包绘制火山图
library(ggpubr)
data$FDR <- -log10(data$FDR)
data$FC <- data$`log2_Ratio(WT0/LOG)`
head(data)
# 基础火山图
ggscatter(data,x="FC",y="FDR")
# 添加颜色，标题，坐标轴标签
ggscatter(data,x="FC",y="FDR",size = 1.5,
          color = "significant", palette = c("#BBBBBB","#CC0000"),
          title = "Volcano plot",xlab = "log2(FC)",ylab = "-log10(FDR)")
# 添加水平线和垂直线，标题居中
ggscatter(data,x="FC",y="FDR",size = 1.5,
          color = "significant", palette = c("#BBBBBB","#CC0000"),
          title = "Volcano plot",xlab = "log2(FC)",ylab = "-log10(FDR)") +
  geom_vline(xintercept=c(-1,1), linetype=2, colour="gray30") +
  geom_hline(yintercept=-log(0.05), linetype=2, colour="gray30") +
  theme(plot.title = element_text(hjust = 0.5))
```

#### MA 散点图

```
data <- read.table("demo_maplot.txt",header = T,
                   check.names = F,row.names = 1,sep="\t")
head(data)
attach(data)
# 基础MAplot
plot(x=(log2(R0_fpkm)+log2(R3_fpkm))/2,y=log2FC)
# 设置点的形状，颜色，坐标轴标题
plot(x=(log2(R0_fpkm)+log2(R3_fpkm))/2,y=log2FC,
     pch=20,col=ifelse(significant=="up","red",
                       ifelse(significant=="down","green","gray")),
     main="MAplot of R3-vs-R0",
     xlab = "Log2 mean expression",ylab = "Log2 fold change")
# 添加水平线和图例
abline(h = 0,lty=1,lwd = 2,col="blue")
abline(h = c(-1,1),lty=2,lwd = 2,col="black")
# 添加图例
legend("topright", inset = 0.01, title = "Significant", c("up","no","down"),
       pch=c(16,16,16),col = c("red","gray","green"))
detach(data)
```

```
# ggplot2包绘制MA散点图
library(ggplot2)
head(data)
# 基础MAplot
ggplot(data,aes(x=(log2(R0_fpkm)+log2(R3_fpkm))/2,y=log2FC)) + geom_point()
# 添加点的颜色，坐标轴标题
ggplot(data,aes(x=(log2(R0_fpkm)+log2(R3_fpkm))/2,y=log2FC,color=significant)) +
  geom_point() + theme_bw() +
  labs(title="MAplot of R3-vs-R0",x="Log2 mean expression", y="Log2 fold change")
# 更改颜色，主题，添加水平线和垂直线，去掉网格线
p <- ggplot(data,aes(x=(log2(R0_fpkm)+log2(R3_fpkm))/2,y=log2FC,color=significant)) +
  geom_point() + theme_bw() +
  labs(title="MAplot of R3-vs-R0",x="Log2 mean expression", y="Log2 fold change") +
  scale_color_manual(values = c("green","gray","red")) +
  geom_hline(yintercept=0, linetype=1, colour="black") +
  geom_hline(yintercept=c(-1,1), linetype=2, colour="gray30") +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())
p
# 添加基因注释信息
library(ggrepel)
gene_selected <- c("OS12T0196300-01","OS01T0239150-00","OS01T0621400-01",
                   "OS02T0577600-00","OS11T0676100-00","OS12T0613150-00",
                   "OS01T0225500-00","OS02T0101900-01")
data_selected <- data[gene_selected,]
head(data_selected)
p + geom_text_repel(data=data_selected, show.legend = F, color="red",
                    aes(label=rownames(data_selected)))
p + geom_label_repel(data=data_selected, show.legend = F,color="blue",
                     aes(label=rownames(data_selected)))
```

```
library(ggpubr)
# 加载示例数据集
data(diff_express)
head(diff_express)
# 基础MAplot
ggmaplot(diff_express, fdr = 0.05, fc = 2, size = 0.4,
         palette = c("red","green","gray"))
# 更改点的颜色，添加标题，更改基因注释名，字体，背景主题
ggmaplot(diff_express, main = expression("Group 1" %->% "Group 2"),
         fdr = 0.05, fc = 2, size = 0.6,
         palette = c("#B31B21", "#1465AC", "darkgray"),
         genenames = as.vector(diff_express$name),
         xlab = "M",ylab = "A",
         legend = "top", top = 20,
         font.label = c("bold", 11),
         font.legend = "bold",
         font.main = "bold",
         ggtheme = ggplot2::theme_minimal())
# 添加基因注释边框，更换top基因筛选标准
ggmaplot(diff_express, main = expression("Group 1" %->% "Group 2"),
         fdr = 0.05, fc = 2, size = 0.4,
         palette = c("#B31B21", "#1465AC", "darkgray"),
         genenames = as.vector(diff_express$name),
         legend = "top", top = 20,
         font.label = c("bold", 11), label.rectangle = TRUE,
         font.legend = "bold", select.top.method = "fc",
         font.main = "bold",
         ggtheme = ggplot2::theme_minimal())
```

#### 气泡图

```
# 基础symbols函数绘制气泡图
attach(mtcars)
symbols(wt,mpg,circles=cyl,
        inches=0.2,
        bg=rainbow(7))
# 添加文本标签
text(wt,mpg,labels = row.names(mtcars),cex=0.7,pos = 3,offset = 0.8)
# 将圆圈换成正方形
symbols(wt,mpg,squares=cyl,
        inches=0.3,
        bg=rainbow(7))
detach(mtcars)
```

```
# ggplot2包绘制富集气泡图
# 基础富集气泡图
ggplot(data,aes(x=richFactor,y=Pathway,size=R0vsR3,color=-log10(Qvalue))) + geom_point()
# 更改颜色，主题，坐标轴标题
ggplot(data,aes(x=richFactor,y=Pathway,size=R0vsR3,color=-log10(Qvalue))) +
  geom_point() + theme_bw() +
  scale_colour_gradient(low="green",high="red") +
  labs(x="GeneRatio",y="Pathway",title="Top20 enriched pathways",
       colour=expression(-log[10]("QValue")),size="Gene number") +
  theme(plot.title = element_text(hjust = 0.5))
```

```
# ggpubr包绘制富集气泡图
# 基础富集气泡图
ggscatter(data,x="richFactor",y="Pathway",
          size = "R0vsR3",color = "-log10(Qvalue)")
# 更改颜色，主题，坐标轴标题
ggscatter(data,x="richFactor",y="Pathway",
          size = "R0vsR3",color = "-log10(Qvalue)",
          xlab="GeneRatio",ylab="Pathway",
          title="Top20 enriched pathways") +
  theme_minimal() +
  scale_colour_gradient(low="green",high="red") +
  labs(colour=expression(-log[10]("QValue")),size="Gene number") +
  theme(plot.title = element_text(hjust = 0.5),legend.position = "right")

```

#### 热图绘制

```
# 使用heatmap函数绘制热图
# 使用mtcars内置数据集
x  <- as.matrix(mtcars)
head(x)
# 设置行的颜色
rc <- rainbow(nrow(x), start = 0, end = .3)
# 设置列的颜色
cc <- rainbow(ncol(x), start = 0, end = .3)
heatmap(x, #表达矩阵
        col = cm.colors(256), #设置热图颜色
        scale = "column", #对列进行归一化
        RowSideColors = rc, #设置行的颜色
        ColSideColors = cc, #设置列的颜色
        margins = c(5,10),
        xlab = "specification variables", #x轴标题
        ylab =  "Car Models", #y轴标题
        main = "heatmap(<Mtcars data>, ..., scale = \"column\")" #主标题
        )

heatmap(x, #表达矩阵
        col = topo.colors(16), #设置热图颜色
        scale = "column", #对列进行归一化
        Colv = NA, #不对列聚类
        RowSideColors = rc, #设置行的颜色
        ColSideColors = cc, #设置列的颜色
        margins = c(5,10),
        cexRow = 1.2, #设置行名字体大小
        cexCol = 1.5, #设置列名字体大小
        xlab = "specification variables", #x轴标题
        ylab =  "Car Models" #y轴标题
)
```

```
# 使用gplots包中的heatmap.2函数绘制热图
library(gplots)
x  <- as.matrix(mtcars)
rc <- rainbow(nrow(x), start=0, end=.3)
cc <- rainbow(ncol(x), start=0, end=.3)

heatmap.2(x, scale="col",
          col=redgreen,
          RowSideColors=rc,
          ColSideColors=cc,
          margin=c(5, 10),
          key=TRUE, # 添加color key
          cexRow = 1.0,
          cexCol = 1.2)

heatmap.2(x, scale="col",
          col=terrain.colors(256),
          RowSideColors=rc,
          ColSideColors=cc,
          margin=c(5, 10),
          colsep = c(7,9), #对列添加分割线
          rowsep = c(16,23), #对行添加分割线
          sepcolor = "white", #设置分割线的颜色
          xlab="specification variables",
          ylab= "Car Models",
          main="heatmap(<Mtcars data>, ..., scale=\"column\")",
          density.info="density", # color key density info
          trace="none" # level trace
          )
```

```
# 使用ggplot2包绘热图
library(ggplot2)
# 构建测试数据集
x <- LETTERS[1:20]
y <- paste0("var", seq(1,20))
data <- expand.grid(X=x, Y=y)
data$Z <- runif(400, 0, 5)
head(data)
# 使用geom_tile()函数绘制热图
ggplot(data, aes(X, Y, fill= Z)) +
        geom_tile()

# 更换填充颜色
# Give extreme colors:
ggplot(data, aes(X, Y, fill= Z)) +
        geom_tile() +
        scale_fill_gradient(low="white", high="blue") +
        theme_bw() #设置主题

# Color Brewer palette
ggplot(data, aes(X, Y, fill= Z)) +
        geom_tile() +
        scale_fill_distiller(palette = "RdPu") +
        theme_classic()

# Color Brewer palette
library(viridis)
ggplot(data, aes(X, Y, fill= Z)) +
        geom_tile() +
        scale_fill_viridis(discrete=FALSE) +
        theme_minimal() + theme(legend.position = "top")
```

```
# 使用lattice包中的levelplot函数绘制热图
library(lattice)
# 构建测试数据集
data <- matrix(runif(100, 0, 5) , 10 , 10)
colnames(data) <- letters[c(1:10)]
rownames(data) <- paste( rep("row",10) , c(1:10) , sep=" ")
head(data)
levelplot(data)   # 绘制热图

# 更换颜色
levelplot(t(data),cuts=30,
          col.regions=heat.colors(100),
          xlab = "",ylab = "",colorkey = list(space="top",width=2))

# try cm.colors() or terrain.colors()
levelplot(volcano, col.regions = terrain.colors(100))   # 类似于热成像图

# 使用RColorBrewer包中的配色
library(RColorBrewer)
coul <- colorRampPalette(brewer.pal(8, "PiYG"))(25)
levelplot(volcano, col.regions = coul)

# 使用viridisLite包中的配色
library(viridisLite)
coul <- viridis(100)
levelplot(volcano, col.regions = coul)
```

#### 相关性图绘制

```
# 基础命令
library(corrgram)
head(iris)
corrgram(iris)

corrgram(iris,
         lower.panel=panel.pts, #设置底部panel绘图类型
         upper.panel=panel.conf, #设置顶部panel绘图类型
         diag.panel=panel.density, #设置对角线panel绘图类型
         main = "Iris data pearson correlation" #设置标题
         )

corrgram(iris,
         lower.panel=panel.shade,
         upper.panel=panel.pie,
         diag.panel=panel.density,
         cor.method = "spearman", #设置相关性计算方法
         gap = 2, #设置图形panel之间的间隔
         col.regions=colorRampPalette(c("green", "blue","red"))
         )
```

```
# 使用corrplot包绘制相关性图
library(corrplot)
head(mtcars)
M <- cor(mtcars,method = "pearson")
corrplot(M)

corrplot(M,
         method = "number", #设置相关性图展示类型
         type = "lower", #设置只展示底部panel
         bg = "white", #设置背景色
         title = "mtcars data correlation", #设置标题
         )

corrplot(M,
         method = "pie", #设置相关性图展示类型
         type = "upper", #设置只展示底部panel
         order = "AOE", #设置排序的方式
         cl.ratio = .2, #设置colorlabel的宽度
         title = "mtcars data pearson correlation", #设置标题
         )
```

```
# 使用ggcorrplot包绘制相关性图
library(ggcorrplot)
head(mtcars)
M <- cor(mtcars,method = "spearman")
ggcorrplot(M)

ggcorrplot(M,
           method = "circle", #设置相关性图展示类型
           outline.color = "red",#设置相关性图边框的颜色
           type = "upper", #设置只展示定部panel
           title = "mtcars data spearman correlation" #设置标题
           )

ggcorrplot(M,
           method = "square", #设置相关性图展示类型
           show.legend = T, #设置是否展示图例
           legend.title = "Corr", #设置图例的标题
           colors = c("#6D9EC1", "white", "#E46726"), #设置相关性图的颜色
           ggtheme = ggplot2::theme_gray, #设置背景
           lab = T, #设置是否显示显关系数
           hc.order = T #设置排序
           )
```

```
# 使用GGally包绘制相关性图
library(GGally)
head(mtcars)
M <- cor(mtcars,method = "kendall")
ggcorr(M)

ggcorr(M,
       label = T, #设置是否显示相关系数
       geom = "circle", #设置相关性图展示类型
       max_size = 10, #设置circles size的最大值
       min_size = 4, #设置circles size的最小值
       size = 4, #设置对角线字体大小
       angle = 45, #设置对角线字体倾斜角度
       low = "green",
       mid = "blue",
       high = "red"
       )
```

#### PCA 图绘制

```
data <- read.table("demo_pca.txt",header = T,row.names = 1,sep="\t",check.names = F)
# 数据转置，转换成行为样本，列为基因的矩阵
data <- t(data)
# prcomp函数进行PCA分析
data.pca <- prcomp(data)
summary(data.pca)   # 查看PCA分析结果
# 绘制主成分的碎石图
screeplot(data.pca, npcs = 10, type = "lines")
```

```
# 使用基础plot函数绘制PCA图
plot(data.pca$x,cex = 2,main = "PCA analysis",
     col = c(rep("red",3),rep("blue",3)),
     pch = c(rep(16,3),rep(17,3)))
# 添加分隔线
abline(h=0,v=0,lty=2,col="gray")
# 添加标签
text(data.pca$x,labels = rownames(data.pca$x),pos = 4,offset = 0.6,cex = 1)
# 添加图例
legend("bottomright",title = "Sample",inset = 0.01,
       legend = rownames(data.pca$x),
       col = c(rep("red",3),rep("blue",3)),
       pch = c(rep(16,3),rep(17,3)))
```

```
# 使用ggplot2包绘制PCA图
library(ggplot2)
# 查看示例数据
head(USArrests)
# 使用princomp函数进行PCA分析
data.pca <- princomp(USArrests,cor = T)
# 查看PCA的结果
summary(data.pca)
# 绘制主成分碎石图
screeplot(data.pca,npcs = 6,type = "barplot")
#查看主成分的结果
pca.scores <- as.data.frame(data.pca$scores)
head(pca.scores)
# 绘制PCA图
ggplot(pca.scores,aes(Comp.1,Comp.2,col=rownames(pca.scores))) +
  geom_point(size=3) +
  geom_text(aes(label=rownames(pca.scores)),vjust = "outward") +
  geom_hline(yintercept = 0,lty=2,col="red") +
  geom_vline(xintercept = 0,lty=2,col="blue",lwd=1) +
  theme_bw() + theme(legend.position = "none") +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(x="PCA_1",y="PCA_2",title = "PCA analysis")
```

```
# 使用scatterplot3d包绘制三维PCA图
library(scatterplot3d)
# 加载示例数据
data <- read.table("demo_pca.txt",header = T,row.names = 1,sep="\t",check.names = F)
head(data)
# 数据转置，转换成行为样本，列为基因的矩阵
data <- t(data)
# 使用prcomp函数进行PCA分析
data.pca <- prcomp(data)
# 绘制三维PCA图
scatterplot3d(data.pca$x[,1:3],
              pch = c(rep(16,3),rep(17,3)),
              color= c(rep("red",3),rep("blue",3)),
              angle=45, main= "3D PCA plot",
              cex.symbols= 1.5,,mar=c(5, 4, 4, 5))
# 添加图例
legend("topright",title = "Sample",
       xpd=TRUE,inset= -0.01,
       legend = rownames(data.pca$x),
       col = c(rep("red",3),rep("blue",3)),
       pch = c(rep(16,3),rep(17,3)))
```

```
# 使用factoextra包绘制PCA图
library(factoextra)
# 查看示例数据
head(iris)
# 使用prcomp函数进行PCA分析
res.pca <- prcomp(iris[, -5],  scale = TRUE)
res.pca
#绘制主成分碎石图
fviz_screeplot(res.pca, addlabels = TRUE)
fviz_pca_ind(res.pca, col.ind="cos2",
             geom = "point", # show points only
             gradient.cols = c("white", "#2E9FDF", "#FC4E07" ))
fviz_pca_ind(res.pca, label="none", habillage=iris$Species,
             addEllipses=TRUE, ellipse.level=0.95,
             palette = c("#999999", "#E69F00", "#56B4E9"))

fviz_pca_var(res.pca, col.var = "steelblue")
fviz_pca_var(res.pca, col.var = "contrib",
             gradient.cols = c("white", "blue", "red"),
             ggtheme = theme_minimal())

fviz_pca_biplot(res.pca, label = "var", habillage=iris$Species,
                addEllipses=TRUE, ellipse.level=0.95,
                ggtheme = theme_minimal())
```

#### tsne 图绘制

```
# 采用鸢尾花数据
head(iris)
# 使用tsne包进行tSNE降维可视化分析
library(tsne)
colors = rainbow(length(unique(iris$Species)))
names(colors) = unique(iris$Species)
head(colors)
# tsne函数进行tsne降维
tsne_iris = tsne(iris[,1:4],k=2,perplexity=50)
# 查看tSNE降维后的结果
head(tsne_iris)
# 使用基础plot函数可视化tSNE降维后的结果
plot(tsne_iris,col=colors[iris$Species],pch=16,
     xlab = "tSNE_1",ylab = "tSNE_2",main = "tSNE plot")
# 添加分隔线
abline(h=0,v=0,lty=2,col="gray")
# 添加图例
legend("topright",title = "Species",inset = 0.01,
       legend = unique(iris$Species),pch=16,
       col = unique(colors[iris$Species]))
```

```
# 使用Rtsne包进行tSNE降维可视化分析
# 加载Rtsne包
library(Rtsne)
iris_unique <- unique(iris) # Remove duplicates
iris_matrix <- as.matrix(iris_unique[,1:4])
head(iris_matrix)
# Set a seed if you want reproducible results
set.seed(42)
# 使用Rtsne函数进行tSNE降维分析
tsne_out <- Rtsne(iris_matrix,pca=FALSE,dims=2,
                  perplexity=30,theta=0.0) # Run TSNE
head(tsne_out)
plot(tsne_out$Y,col=iris_unique$Species, asp=1,pch=20,
     xlab = "tSNE_1",ylab = "tSNE_2",main = "tSNE plot")
# 添加分隔线
abline(h=0,v=0,lty=2,col="gray")
# 添加图例
legend("topright",title = "Species",inset = 0.01,
       legend = unique(iris_unique$Species),pch=16,
       col = unique(iris_unique$Species))
```

#### UMAP 图绘制

```
head(iris)  # 鸢尾花数据
library(umap)
# 使用umap函数进行UMAP降维分析
iris.umap = umap::umap(iris.data)
iris.umap
# 查看降维后的结果
head(iris.umap$layout)
# 使用plot函数可视化UMAP的结果
plot(iris.umap$layout,col=iris.labels,pch=16,asp = 1,
     xlab = "UMAP_1",ylab = "UMAP_2",
     main = "A UMAP visualization of the iris dataset")
# 添加分隔线
abline(h=0,v=0,lty=2,col="gray")
# 添加图例
legend("topright",title = "Species",inset = 0.01,
       legend = unique(iris.labels),pch=16,
       col = unique(iris.labels))
```

```
# 使用uwot包进行UMAP降维可视化分析
library(uwot)
head(iris)
# 使用umap函数进行UMAP降维分析
iris_umap <- uwot::umap(iris)
head(iris_umap)
# 使用plot函数可视化UMAP降维的结果
plot(iris_umap,col=iris$Species,pch=16,asp = 1,
     xlab = "UMAP_1",ylab = "UMAP_2",
     main = "A UMAP visualization of the iris dataset")
# 添加分隔线
abline(h=0,v=0,lty=2,col="gray")
# 添加图例
legend("topright",title = "Species",inset = 0.01,
       legend = unique(iris$Species),pch=16,
       col = unique(iris$Species))
```


#### 峰峦图
```
# 使用ggridges包绘制峰峦图
library(ggridges)
library(ggplot2)
head(iris)
# 使用geom_density_ridgesh函数绘制峰峦图
ggplot(iris, aes(x=Sepal.Length, y=Species, fill=Species)) +
  geom_density_ridges()
# 设置分面
ggplot(iris, aes(x = Sepal.Length, y = Species)) + 
  geom_density_ridges(scale = 1) + 
  facet_wrap(~Species)
# 添加jitter散点
ggplot(iris, aes(x=Sepal.Length, y=Species)) +
  geom_density_ridges(jittered_points = TRUE) + 
  theme_ridges()
# 设置散点的大小和颜色
ggplot(iris, aes(x = Sepal.Length, y = Species, fill = Species)) +
  geom_density_ridges(
    aes(point_shape = Species, point_fill = Species, point_size = Petal.Length), 
    alpha = .2, point_alpha = 1, jittered_points = TRUE
  ) +
  scale_point_color_hue(l = 40) + 
  scale_point_size_continuous(range = c(0.5, 4)) +
  scale_discrete_manual(aesthetics = "point_shape", values = c(21, 22, 23))
```
```
# viridis绘制
library(viridis)
head(lincoln_weather)
ggplot(lincoln_weather, aes(x = `Mean Temperature [F]`, y = `Month`, fill = ..x..)) +
  geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01, gradient_lwd = 1.) +
  scale_x_continuous(expand = c(0.01, 0)) +
  scale_y_discrete(expand = c(0.01, 0)) +
  scale_fill_viridis(name = "Temp. [F]", option = "C") +
  labs(
    title = 'Temperatures in Lincoln NE',
    subtitle = 'Mean temperatures (Fahrenheit) by month for 2016\nData: Original CSV from the Weather Underground'
  ) +
  theme_ridges(font_size = 13, grid = TRUE) + theme(axis.title.y = element_blank())
```

#### 蜂群图
```
# 使用beeswarm包绘制蜂群图
# 安装并加载所需的R包
#install.packages("beeswarm")
library(beeswarm)
# 查看示例数据
data(breast)
head(breast)
# 使用beeswarm函数绘制蜂群图
beeswarm(time_survival ~ ER,
         data = breast,pch = 16,
         pwcol = 1 + as.numeric(event_survival),
         xlab = "", ylab = "Follow-up time (months)",
         labels = c("ER neg", "ER pos"))
# 添加图例
legend("topright", legend = c("Yes", "No"),
       title = "Censored", pch = 16, col = 1:2)

## Compare the 4 methods
# 使用method参数设置蜂群点分布的方法
op <- par(mfrow = c(2,2))
for (m in c("swarm", "center", "hex", "square")) {
  beeswarm(distributions, method = m, 
           main = paste0("method = ", m), 
           pch = 16, pwcol = myCol)
}
par(op)
## Demonstrate the 'corral' methods
# 使用corral参数调整组外离群点的分布
op <- par(mfrow = c(2,3))
beeswarm(distributions, col = 2:4, 
         main = 'corral = "none" (default)')
beeswarm(distributions, col = 2:4, corral = "gutter", 
         main = 'corral = "gutter"')
beeswarm(distributions, col = 2:4, corral = "wrap", 
         main = 'corral = "wrap"')
beeswarm(distributions, col = 2:4, corral = "random", 
         main = 'corral = "random"')
beeswarm(distributions, col = 2:4, corral = "omit", 
         main = 'corral = "omit"')  
par(op)
## Demonstrate 'side' and 'priority'
# 调整蜂群点的排序和分布形式
op <- par(mfrow = c(2,3))
beeswarm(distributions, col = 2:4, 
         main = 'Default')
beeswarm(distributions, col = 2:4, side = -1, 
         main = 'side = -1')
beeswarm(distributions, col = 2:4, side = 1, 
         main = 'side = 1')
beeswarm(distributions, col = 2:4, priority = "descending", 
         main = 'priority = "descending"')
beeswarm(distributions, col = 2:4, priority = "random", 
         main = 'priority = "random"')  
beeswarm(distributions, col = 2:4, priority = "density", 
         main = 'priority = "density"')  
par(op)
```
```
# 使用ggbeeswarm包绘制蜂群图
library(ggbeeswarm)
head(breast)
# 使用geom_beeswarm函数绘制蜂群图
ggplot(breast,aes(x=ER,y=time_survival))+
  geom_beeswarm(aes(color=factor(event_survival)),cex=1.5,size=2)+
  theme_bw()+
  labs(x="",y="Follow-up time (months)") +
  scale_color_manual(values=c("black","red"),name="Censored",labels=c("Yes","No")) +
  scale_x_discrete(labels=c("ER neg","ER pos"))

```